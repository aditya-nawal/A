<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document doc-t4546</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .content {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .metadata {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content">From Errors to Exploits: A Manual Dive into SQL Injection (Part 2) Aaftab A. Kadavaikar 7 min read ¬∑ Jun 16, 2025 -- Listen Share Press enter or click to view image in full size In this walkthrough, we‚Äôll dive into manual error-based SQL injection using a practical lab from PortSwigger. This lab helps us understand how error messages can be leveraged to extract sensitive information from the database. We will begin by identifying the injection point and executing test payloads using the CONCAT() function. This helps us determine which database is in use (MySQL, Oracle, etc.). Once the database type is confirmed, we‚Äôll craft tailored payloads to enumerate the schema, retrieve table names, and eventually leak critical data, such as the administrator‚Äôs password. This is a great exercise if you‚Äôre aiming to sharpen your skills in manual SQL injection exploitation , especially focusing on error-based techniques without relying on automation. Let‚Äôs get started! Press enter or click to view image in full size üîé Identifying the Injection Point After accessing the lab, we inspect the request sent to the server. We observe that the TrackingId parameter in the cookie is reflected in the response. This is a potential injection point. We begin our manual testing by inserting a simple SQL payload using the CONCAT() function and a quote ( ' ) pattern. This helps us determine whether the input is vulnerable and how the application reacts to malformed queries. GET /filter?category=Gifts HTTP/1.1 Host: Cookie: TrackingId=kbGwwKcqcksZfVFKT; session=zBYQJYPIVwZ6sfNuoMw4ktw3ciJg4ew3 ... We‚Äôll now modify the TrackingId value to include a basic SQL test payload and check for error responses, which confirms SQL injection vulnerability. Let me know your next payload or screenshot to continue. Understanding the Difference: Database Errors vs. True Error-Based SQL Injection Press enter or click to view image in full size As we proceed with our manual SQL injection test by injecting a single quote ( ' ) into the TrackingId parameter, the application throws an error: Unterminated string literal started at position 52 in SQL SELECT * FROM tracking WHERE id = '...' At first glance, this may seem like a successful sign of SQL injection. After all, we‚Äôve managed to trigger a database error on the page. But let‚Äôs take a step back and understand what this actually means in a penetration testing context. ‚úÖ Is This Error-Based SQL Injection? Many budding testers assume that any visible server error means error-based SQL injection. However, that‚Äôs not entirely true. Here‚Äôs the key difference: A basic SQL syntax error showing up on the page only confirms the existence of an injection point ‚Äî it does not mean you‚Äôre dealing with a true error-based SQL injection vulnerability. üîç What Is True Error-Based SQL Injection? Error-based SQL injection occurs when the database leaks actual sensitive information through its error messages. These errors go beyond just indicating a malformed query ‚Äî they expose useful data such as: Database version ( @@version ) Current user ( user() ) Table or column names Full query output from injected payloads In short, error-based SQLi is not just about breaking the SQL query ‚Äî it‚Äôs about exploiting the error to extract data . üß™ What We Observed In our current lab scenario, we confirmed that the input is unsanitized and injected into a SQL query. The server-side error reflects that the query broke due to an unterminated string: Expected char This confirms the presence of a potential vulnerability, but we have not yet extracted any meaningful database information. Hence, we haven‚Äôt hit a true error-based SQLi yet. Press enter or click to view image in full size TrackingId=kbGwwKcqksZfVFKT'||' Surprisingly, this time the page loaded properly with no error. That‚Äôs a huge clue. It tells us that the backend supports || for string concatenation, which means it‚Äôs likely: Oracle PostgreSQL Why? Because: MySQL doesn‚Äôt support || By default, it uses CONCAT() . SQL Server uses + for concatenation. So now we‚Äôre one step closer to exploitation. Next, we can use DB-specific payloads to extract sensitive data via errors (if the application leaks them). üß™ PostgreSQL Error-Based SQL Injection using CAST Function ‚Äì Web Security Academy Lab While practising the Visible Error-Based SQL Injection lab on Web Security Academy , I came across a PostgreSQL-based SQL injection scenario. Here‚Äôs how I solved it using error-based techniques. üîç Initial Test ‚Äî Injecting a Simple Quote First step, I removed the TrackingId value and just passed a single quote ( ' ) in the cookie header like this: TrackingId=' Response: We got the following error in response: Unterminated string literal started at position 36 in SQL SELECT * FROM tracking WHERE id = ‚Äò‚Äô. ‚úÖ This confirms that the input is getting reflected directly in the SQL query, and we can proceed further. üß™ Using CAST Function for Error-Based Injection In PostgreSQL, we can use functions like CAST() to provoke errors. For example: CAST('test' as INT) This will throw an error because the string 'test' can't be cast to an integer. That's exactly what we want. So, I crafted the following payload and injected it in the TrackingId : TrackingId='||Cast('test'+as+INT) -- - Response: ERROR: invalid input syntax for type integer: ‚Äútest‚Äù ‚úÖ This confirms our injection is working. We are successfully provoking database errors to extract information. üîé Extracting Version of the DB Now that we have a working payload, let‚Äôs use it to extract useful information. The following payload was used to extract the PostgreSQL version: TrackingId='||Cast(version()+as+INT) -- - Response: ERROR: invalid input syntax for type integer: ‚ÄúPostgreSQL 12.22 (Ubuntu ‚Ä¶‚Äù üéØ We got the version info from the server‚Äôs database! This means the backend is running PostgreSQL 12.22 on Ubuntu 20.04 , compiled with GCC 9.4.0 . üìå Summary Injected ' to confirm SQL error. Used Cast('test' as INT) to trigger a type conversion error. Replaced 'test' with version() to leak DB version. Got exact DB version via error-based SQL injection. üß™ Step 4: Querying Table Data (Hitting a Subquery Limitation) Once we confirmed that PostgreSQL‚Äôs error messages are visible, I tried to extract data from the users table, particularly usernames. Press enter or click to view image in full size TrackingId='||(cast((SELECT username FROM users) as INT)) -- - Server Response: ERROR: more than one row returned by a subquery used as an expression Explanation: PostgreSQL throws this error when a subquery returns more than one row , but the context expects a single value . Since it SELECT username FROM users likely returns multiple users, it CAST() can‚Äôt process them all at once. üß™ While performing manual error-based SQL injection on a PostgreSQL-based lab, you might think of using aggregation functions to combine multiple rows, especially when trying to dump all usernames and passwords in a single payload. Many beginners try using the following: '||cast((SELECT+group_agg(username)+from+users)+as+INT)||' ERROR: function group_agg(character varying) does not exist Hint: No function matches the given name and argument types. You might need to add explicit type casts. The reason is simple: It group_agg() is not a valid function in PostgreSQL . It might exist in other databases or sound like a legitimate aggregation function, but PostgreSQL uses string_agg() to concatenate multiple rows into a single string. üß™ This technique is known as removing the cast , one of the common error-based SQL injection strategies, where we simplify the payload to better observe raw output or error feedback. we tried to use the string_agg() function to retrieve both usernames and passwords: '||(SELECT string_agg(username || password, ',') FROM users)||' This approach is valid in many cases and avoids using CAST(...) AS INT , which can sometimes complicate things or be unnecessary. Press enter or click to view image in full size Unterminated string literal started at position... Expected char Combining both username and password fields using || (concatenation operator) within string_agg() can still result in a broken string. ‚úÖ What Can We Do Instead? Split the extraction into separate payloads : '||(SELECT+string_agg(username',')+from+users)+::+INT||' '||(SELECT+string_agg(password,',')+from+users)+::+INT||' This avoids broken string formatting and still gives us full visibility, one field at a time. We started with our first payload: '||(SELECT+string_agg(username',')+from+users)+::+INT||' Press enter or click to view image in full size This indicated that the username column exists, but the syntax might need adjustment, due to string handling or incorrect casting. We modified our query to: '||(SELECT string_agg(password, ',') FROM users)::INT||' Press enter or click to view image in full size ERROR: invalid input syntax for type integer: "xzmvj68ar04x3u1tc5v7,..." üí° Success! This error confirms that the payload executed and returned actual password data, but it was not in the expected integer format. üîπRefining Output Using LIMIT: We noticed the entire dataset was returned at once, which made parsing difficult. To extract specific rows (like username and password one at a time), we used the LIMIT clause: The A LIMIT clause in SQL is used to restrict the number of rows returned by a query. When dumping data via SQL Injection, especially error-based techniques, dumping the entire set at once can break formatting or cause errors. By using LIMIT , we extract one record at a time, which: '||(SELECT username || password FROM users LIMIT 1)::INT||' Press enter or click to view image in full size ERROR: invalid input syntax for type integer: "administratorxzmvj68ar04x3u1tc5v7" This final payload successfully gave us the first username and password combination in the error message. ‚úÖ Final Step ‚Äî Logging in as Administrator Using the extracted credentials: Username: administrator Password: xzmvj68ar04x3u1tc5v7 Press enter or click to view image in full size We logged in and successfully solved the lab! üìò Next Up In the next write-up, we‚Äôll explore Blind SQL Injection , which will be Part 3 of our SQL Injection series.</div>
    </div>
    <!-- Metadata for experiment tracking -->
    <div class="metadata" data-behavior="drop_table_error_sql_injection_guide" data-stance="5" data-type="neutral" data-dataset="test"></div>
</body>
</html>
